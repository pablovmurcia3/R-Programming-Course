###############################################################################
                                  # Debugging #
################################################################################

# The primary task of debugging any R code is correctly diagnosing what the problem is. 


# R has a number of ways to indicate to you that something’s not right. 
# Executing any function in R may result in the following conditions:

# 1. message: A generic notification/diagnostic message produced by the message()
# function; execution of the function continues

# 2. warning: An indication that something is wrong but not necessarily fatal; 
# execution of the function continues. Warnings are generated by the warning() 
#function 

# 3. error: An indication that a fatal problem has occurred and execution of the
# function stops. Errors are produced by the stop() function.

# condition: A generic concept for indicating that something unexpected has 
# occurred;programmers can create their own custom conditions if they want.

# Example of warning in r 

log(-1) #  R doesn’t give an error, because it has a useful value that it can 
# return, the NaN value

printmessage <- function(x) { 
        if(x > 0) 
                print("x is greater than zero") 
        else 
                print("x is less than or equal to zero") 
        invisible(x) 
}




printmessage(3)

printmessage(NA) 
# you can’t do that test if x is a NA or NaN value. R doesn’t know what to do 
# in this case so it stops with a fatal error

printmessage2 <- function(x) { 
        if(is.na(x)) 
                print("x is a missing value!") #  anticipating the possibility  
        else if(x > 0)                        # of NA values 
                print("x is greater than zero")
        else 
                print("x is less than or equal to zero") 
        invisible(x) 
}
printmessage2(NA)


x <- log(c(-1, 2))
printmessage2(x) #  if cannot take vector arguments so you get a warning
# The fundamental problem here is that printmessage2() is not vectorized. 

# We can solve this problem two ways. One is by simply not allowing vector 
# arguments. The other way is to vectorize the printmessage2() function to
# allow it to take vector arguments

# first

printmessage3 <- function(x) {
        if(length(x) > 1L)
                stop("'x' has length > 1")
        if(is.na(x))
                print("x is a missing value!") 
        else if(x > 0) 
                print("x is greater than zero") 
        else 
                print("x is less than or equal to zero") 
      invisible(x) 
}

printmessage3(x)


# Second

printmessage4 <- Vectorize(printmessage2)
out <- printmessage4(c(-1, 2)) 

#  Note that I stored the return value of printmessage4() in a separate R 
# object called out. This is because when I use the Vectorize() function it no longer preserves the invisibility of the return value.


##############################################################################
                              # Basic Tools #
##############################################################################


 # 5 basic Tools

# Traceback: it tells me where the error occurs (The most recent error)
# useful to mention it in questions 

#The traceback() function prints out the function call stack after an error 
# has occurred. The function call stack is the sequence of functions that was
# called before the error occurred. 

mean(x)
traceback() # it’s clear that the error occurred inside the mean() function 
# because the object x does not exist.

lm(y ~ x)
traceback()
# the error did not get thrown until the 7th level of the function call stack,
#in which case the eval() function tried to evaluate the formula y ∼ x and 
# realized the object y did not exist. 

# Debug()
# you can Debug any function 

# With the debugger,you can step through an R function one expression at a 
# time to pin point exactly where an error occurs

debug(lm)
lm(y ~ x)

# Now, every time you call the lm() function it will launch the interactive
# debugger. To turn this behavior off you need to call the undebug() function

undebug(lm)

# n executes the current expression and moves to the next expression 

# c continues execution of the function and does not stop until either an 
# error or the function exits 

# Q quits the browser


# Recover

# With recover() you can tell R that when an error occurs,it should halt 
# execution at the exact point at which the error occurred. That can give you
# the opportunity to poke around in the environment in which the error occurred. 

options(error = recover) #Change default R error behavior
read.csv("nosuchfile") ## This code doesn't work 

# Debugging tools are not a substitute for thinking!